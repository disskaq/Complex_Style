<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>freemodbus: Modbus Registers</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">freemodbus
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Поиск');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Загрузка...</div>
<div class="SRStatus" id="Searching">Поиск...</div>
<div class="SRStatus" id="NoMatches">Не найдено</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Функции</a>  </div>
  <div class="headertitle"><div class="title">Modbus Registers</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Функции</h2></td></tr>
<tr class="memitem:ga7816677520b1eb2ebecf15060a41bc81" id="r_ga7816677520b1eb2ebecf15060a41bc81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga7816677520b1eb2ebecf15060a41bc81">eMBRegInputCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs)</td></tr>
<tr class="memdesc:ga7816677520b1eb2ebecf15060a41bc81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used if the value of a <em>Input Register</em> is required by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>.  <br /></td></tr>
<tr class="separator:ga7816677520b1eb2ebecf15060a41bc81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10d37e1d80224bf3b1eeb9e246d7582e" id="r_ga10d37e1d80224bf3b1eeb9e246d7582e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga10d37e1d80224bf3b1eeb9e246d7582e">eMBRegHoldingCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNRegs, <a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a> eMode)</td></tr>
<tr class="memdesc:ga10d37e1d80224bf3b1eeb9e246d7582e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used if a <em>Holding Register</em> value is read or written by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>.  <br /></td></tr>
<tr class="separator:ga10d37e1d80224bf3b1eeb9e246d7582e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88d9b719291515c60eee1bf9ffa1dd02" id="r_ga88d9b719291515c60eee1bf9ffa1dd02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga88d9b719291515c60eee1bf9ffa1dd02">eMBRegCoilsCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNCoils, <a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a> eMode)</td></tr>
<tr class="memdesc:ga88d9b719291515c60eee1bf9ffa1dd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used if a <em>Coil Register</em> value is read or written by the protocol stack. If you are going to use this function you might use the functions <a class="el" href="group__modbus__utils.html#gaffd1defb8bceb85f1b65d64fa1c895e1" title="Function to set bits in a byte buffer.">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga94b3b43e1d2353e621748c79e2fb4dd5" title="Function to read bits in a byte buffer.">xMBUtilGetBits(  )</a> for working with bitfields.  <br /></td></tr>
<tr class="separator:ga88d9b719291515c60eee1bf9ffa1dd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38101f5da54af137e210a3b8b9fa3887" id="r_ga38101f5da54af137e210a3b8b9fa3887"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ga38101f5da54af137e210a3b8b9fa3887">eMBRegDiscreteCB</a> (UCHAR *pucRegBuffer, USHORT usAddress, USHORT usNDiscrete)</td></tr>
<tr class="memdesc:ga38101f5da54af137e210a3b8b9fa3887"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback function used if a <em>Input Discrete Register</em> value is read by the protocol stack.  <br /></td></tr>
<tr class="separator:ga38101f5da54af137e210a3b8b9fa3887"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mb_8h.html">mb.h</a>&quot;</span> </div>
<div class="ttc" id="amb_8h_html"><div class="ttname"><a href="mb_8h.html">mb.h</a></div></div>
</div><!-- fragment --><p> The protocol stack does not internally allocate any memory for the registers. This makes the protocol stack very small and also usable on low end targets. In addition the values don't have to be in the memory and could for example be stored in a flash.<br  />
 Whenever the protocol stack requires a value it calls one of the callback function with the register address and the number of registers to read as an argument. The application should then read the actual register values (for example the ADC voltage) and should store the result in the supplied buffer.<br  />
 If the protocol stack wants to update a register value because a write register function was received a buffer with the new register values is passed to the callback function. The function should then use these values to update the application register values. </p>
<h2 class="groupheader">Функции</h2>
<a id="ga88d9b719291515c60eee1bf9ffa1dd02" name="ga88d9b719291515c60eee1bf9ffa1dd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88d9b719291515c60eee1bf9ffa1dd02">&#9670;&#160;</a></span>eMBRegCoilsCB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegCoilsCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *</td>          <td class="paramname"><span class="paramname"><em>pucRegBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usAddress</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usNCoils</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a></td>          <td class="paramname"><span class="paramname"><em>eMode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Coil Register</em> value is read or written by the protocol stack. If you are going to use this function you might use the functions <a class="el" href="group__modbus__utils.html#gaffd1defb8bceb85f1b65d64fa1c895e1" title="Function to set bits in a byte buffer.">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga94b3b43e1d2353e621748c79e2fb4dd5" title="Function to read bits in a byte buffer.">xMBUtilGetBits(  )</a> for working with bitfields. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>The bits are packed in bytes where the first coil starting at address <code>usAddress</code> is stored in the LSB of the first byte in the buffer <code>pucRegBuffer</code>. If the buffer should be written by the callback function unused coil values (I.e. if not a multiple of eight coils is used) should be set to zero. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The first coil number. </td></tr>
    <tr><td class="paramname">usNCoils</td><td>Number of coil values requested. </td></tr>
    <tr><td class="paramname">eMode</td><td>If eMBRegisterMode::MB_REG_WRITE the application values should be updated from the values supplied in the buffer <code>pucRegBuffer</code>. If eMBRegisterMode::MB_REG_READ the application should store the current values in the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application does not map an coils within the requested address range. In this case a <b>ILLEGAL DATA ADDRESS</b> is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga38101f5da54af137e210a3b8b9fa3887" name="ga38101f5da54af137e210a3b8b9fa3887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38101f5da54af137e210a3b8b9fa3887">&#9670;&#160;</a></span>eMBRegDiscreteCB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegDiscreteCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *</td>          <td class="paramname"><span class="paramname"><em>pucRegBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usAddress</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usNDiscrete</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Input Discrete Register</em> value is read by the protocol stack. </p>
<p>If you are going to use his function you might use the functions <a class="el" href="group__modbus__utils.html#gaffd1defb8bceb85f1b65d64fa1c895e1" title="Function to set bits in a byte buffer.">xMBUtilSetBits(  )</a> and <a class="el" href="group__modbus__utils.html#ga94b3b43e1d2353e621748c79e2fb4dd5" title="Function to read bits in a byte buffer.">xMBUtilGetBits(  )</a> for working with bitfields.</p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>The buffer should be updated with the current coil values. The first discrete input starting at <code>usAddress</code> must be stored at the LSB of the first byte in the buffer. If the requested number is not a multiple of eight the remaining bits should be set to zero. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the first discrete input. </td></tr>
    <tr><td class="paramname">usNDiscrete</td><td>Number of discrete input values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If no such discrete inputs exists. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga10d37e1d80224bf3b1eeb9e246d7582e" name="ga10d37e1d80224bf3b1eeb9e246d7582e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10d37e1d80224bf3b1eeb9e246d7582e">&#9670;&#160;</a></span>eMBRegHoldingCB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegHoldingCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *</td>          <td class="paramname"><span class="paramname"><em>pucRegBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usAddress</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usNRegs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__modbus.html#gaf1398cbbeb317b1dbd0276b275f5b0f8">eMBRegisterMode</a></td>          <td class="paramname"><span class="paramname"><em>eMode</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if a <em>Holding Register</em> value is read or written by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>If the application registers values should be updated the buffer points to the new registers values. If the protocol stack needs to now the current values the callback function should write them into this buffer. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the register. </td></tr>
    <tr><td class="paramname">usNRegs</td><td>Number of registers to read or write. </td></tr>
    <tr><td class="paramname">eMode</td><td>If eMBRegisterMode::MB_REG_WRITE the application register values should be updated from the values in the buffer. For example this would be the case when the Modbus master has issued an <b>WRITE SINGLE REGISTER</b> command. If the value eMBRegisterMode::MB_REG_READ the application should copy the current values into the buffer <code>pucRegBuffer</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="ga7816677520b1eb2ebecf15060a41bc81" name="ga7816677520b1eb2ebecf15060a41bc81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7816677520b1eb2ebecf15060a41bc81">&#9670;&#160;</a></span>eMBRegInputCB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__modbus.html#ga9e7fce8c431cb0e521c67f7f36dd823d">eMBErrorCode</a> eMBRegInputCB </td>
          <td>(</td>
          <td class="paramtype">UCHAR *</td>          <td class="paramname"><span class="paramname"><em>pucRegBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usAddress</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">USHORT</td>          <td class="paramname"><span class="paramname"><em>usNRegs</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback function used if the value of a <em>Input Register</em> is required by the protocol stack. The starting register address is given by <code>usAddress</code> and the last register is given by <code>usAddress + usNRegs - 1</code>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">pucRegBuffer</td><td>A buffer where the callback function should write the current value of the modbus registers to. </td></tr>
    <tr><td class="paramname">usAddress</td><td>The starting address of the register. Input registers are in the range 1 - 65535. </td></tr>
    <tr><td class="paramname">usNRegs</td><td>Number of registers the callback function must supply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>The function must return one of the following error codes:<ul>
<li>eMBErrorCode::MB_ENOERR If no error occurred. In this case a normal Modbus response is sent.</li>
<li>eMBErrorCode::MB_ENOREG If the application can not supply values for registers within this range. In this case a <b>ILLEGAL DATA ADDRESS</b> exception frame is sent as a response.</li>
<li>eMBErrorCode::MB_ETIMEDOUT If the requested register block is currently not available and the application dependent response timeout would be violated. In this case a <b>SLAVE DEVICE BUSY</b> exception is sent as a response.</li>
<li>eMBErrorCode::MB_EIO If an unrecoverable error occurred. In this case a <b>SLAVE DEVICE FAILURE</b> exception is sent as a response. </li>
</ul>
</dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Создано системой&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
